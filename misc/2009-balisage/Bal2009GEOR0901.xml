<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.balisage.net/DocumentModels/balisage-1-1.rng" type="xml"?>

<article xmlns="http://docbook.org/ns/docbook">
   <title>A practical introduction to EXPath</title>
   <subtitle>Collaboratively Defining Open Standards for Portable XPath Extensions</subtitle>
   <info>
      <confgroup>
         <conftitle>Balisage: The Markup Conference</conftitle>
         <confdates>11 - 14 August 2009</confdates>
      </confgroup>
      <abstract>
         <para>For some months ago, extensions are more and more demanded, needed among the XML Core
            technologies, especially XSLT and XQuery. Looking at EXSLT and EXQuery projects, one
            will see that their goals are useful, but also that they overlap, as does their common
            core: XPath. It is thus reasonable to share the job and to work at the common, XPath
            level. In addition, any XPath-based language or processor could then benefit from those
            extensions.</para>
      </abstract>
      <author>
         <personname>
            <firstname>Florent</firstname>
            <surname>Georges</surname>
         </personname>
         <personblurb>
            <para>Florent is bla bla bla... TODO: ...</para>
         </personblurb>
         <affiliation>
            <jobtitle>XML Architect</jobtitle>
            <orgname>fgeorges.org</orgname>
         </affiliation>
         <email>fgeorges@fgeorges.org</email>
      </author>
      <legalnotice>
         <para>Copyright &#x000A9; 2009 Florent Georges. Used by permission.</para>
      </legalnotice>
      <keywordset role="author">
         <keyword>EXPath</keyword>
         <keyword>extension</keyword>
         <keyword>XPath</keyword>
         <keyword>XSLT</keyword>
         <keyword>XQuery</keyword>
      </keywordset>
   </info>
   <section>
      <title>Note to reviewers</title>
      <para>The EXPath project has just been launched three days ago (as I start this document.) So
         this paper is a first draft and presents initial thoughts about the project and its
         potential evolution, and it is going to change over the following months, to reflect more
         accurate and up-to-date information (while the main idea will remain the same, of course.)
         The first part presents the context, the project and the definition process, and thus has
         more risks to change. But the second one introduces real, cool examples dealing with REST
         and SOAP services using an HTTP extension, as well as with Open Document files through a
         ZIP extension, and is not really going to change.</para>
      <para>About the examples, I didn't feel comfortable with explaining every single line of code.
         Of course, some examples can be quite heavy, but live explanation will solve that
         :-)</para>
   </section>
   <section>
      <title>Introduction</title>
      <!--para>In the beginning of 2009, XPath 2.0, XQuery and XSLT 2.0 recommendations were going to
         be 2 years old. While that's still young, the community around them had a lot of feedback
         yet, accumulated for several years of use, even before they reached the status of
         recommendation at W3C. There began to be more and more activity around various extension
         projects to fulfil needs not covered by those recommendations, as EXQuery, or a new version
         of the well-known EXSLT project.</para>
      <para>Those projects try to provide new features to XQuery and XSLT, respectively. Those
         features are usually the same on both sides, and the result is usually to define and
         implement for several processor new XPath extension functions. </para>
      <para>TODO: FUCK! THAT DOES NOT WORK!!! ... REWORK THE INTRO!</para>
   </section>
   <section>
      <title>The project</title-->
      <para>XPath is a textual language to query XML content. Besides a very convenient way to
         navigate within an XML document through a path system, it provides the ability to make
         various kind of computation, like string manipulations or dates and times handling. Most of
         those features are provided as functions, defined in a separate recommendation defining the
         standard library. It is also possible to use other functions, in an implementation-defined
         way. For instance, XSLT and XQuery use that fact and allow one to define new functions
         directly in the stylesheet or in the query module. An XPath processor usually provides
         libraries of additional functions, as well as a way to augment the set of available
         functions by writing new functions in Java, or Python or whatever language it has been
         written with.</para>
      <para>That leads to the concept of extension function. This is not defined by XPath, but
         inspired by XSLT this is defined as any function available in an expression while not
         defined in any recommendation. There are two major kinds of extension functions: those
         provided by the processor itself, and those written by the user. A processor can provide
         extensions to deal with database management for instance, and the user can implement any
         processing he could not write in XPath directly. For instance using a complex mathematical
         library available in Java. Possible useful extensions can provide support for performing
         HTTP requests, using WebDAV, reading and writing ZIP files (like EPUB eBook, Open XML and
         OpenDocument files,) parsing and serializing XML and HTML documents, executing XSLT
         transforms and XQuery queries, etcetera.</para>
      <para>Extension functions are a very powerful way to extend XPath features. And a lot of
         extensions have been written over the years, by many people. But it is hard, to not say
         impossible, to share an extension function among several processors, and to maintain them
         over time. And the extension functions provided by processors themselves are not
         compatible, so an expression that uses them is not portable. That situation lead to the
         creation of a project that would define libraries of extension functions from the outside
         of any single processor, allowing existing processors to choose to implement them natively,
         or a user to install the existing implementation as an external package in his processor.
         That way, it becomes possible to use extension functions already defined and implemented,
         and at least as important, to write expressions that become portable across every
         processors that support the extension or that an implementation was provided to.</para>
      <para>This is exactly what EXPath is.</para>
   </section>
   <section>
      <title>The project</title>
      <para>The project has been launched four months ago, in April 2009. It is divided in several
         modules, rather independent from each other. The module is the delivery unit of EXPath. It
         is a consistent set of functions providing support for a particular domain, and can be view
         as a specific library of functions. Besides the specification of the functions itself,
         implementations are provided for various processors. The first module that has been defined
         is the HTTP Client. It provides support for sending HTTP request and handling their
         responses. This module defines a single one function, how it represents HTTP requests and
         responses as XML elements, and how it can be used to perform requests. It has also been
         implemented for various processors (as the standalone XSLT and XQuery processor Saxon, the
         XML database eXist, or MarkLogic Server) and implementations are provided on the website as
         open source packages.</para>
      <para>If someone needs new extension functions to address missing features, he can propose to
         add a new module, with the help of other people interested in supporting the same features.
         First he has to identify precise use cases for this feature, and describe examples of use.
         That defines the scope of the module. Of course the scope can evolve over time, as well as
         the use case examples, but that gives a formal basis for further discussions and marks the
         trail to the specification.</para>
      <para>Once the use cases have been identified, he has to propose a definition of the module,
         and of all its functions. That proposal is discussed among the community through the
         mailing list, and people interested in this module help to solve issues and to improve the
         design. Extensions addressing the same problem can already exist, either built-in in some
         processors, or developed as independent, individual projects; of course, they are valuable
         materials to learn from during this stage. In parallel with this definition, it is
         encouraged to develop at least one implementation to validate the feasibility of what is
         specified (sometimes, there is something else quite as practical as a good theory.) Before
         being officially endorsed as a module, at least two implementations should have been
         provided, to ensure the specification is not too closely tight to a particular
         processor.</para>
      <para>Each module has its own maintainer, who is responsible to edit the specification, lead
         the discussions and make design choices in accordance to those discussions. Similarly,
         every implementation of a module for a particular processor has its own maintainer. If
         someone needs the module to be implemented to another processor, he can volunteer for that
         work, and propose an implementation. Test suite for the module should be carefully designed
         to be sure every implementation reach the proper quality level. Of course, a processor
         might also propose natively an implementation for some modules, in which case its
         implementers takes the responsibility for the code they provide.</para>
      <para>An interesting point about implementing a module is when a processor already provides a
         similar feature through processor-specific extension functions. It could then be possible,
         in some case, to reuse those existing extensions through a tiny wrapper exposing the EXPath
         interface to the user. For instance, the HTTP Client has been implemented for MarkLogic
         Server with an XQuery module using MarkLogic's own HTTP Client set of extension functions.
         This example shows also the limitations of this approach: the implementation is only
         partial, because the MarkLogic's extensions do not provide exactly all the possibilities
         required by the EXPath HTTP Client module.</para>
      <para>As you can see, there is a lot of work, and everyone is welcome to help, at any level:
         write specifications, review and comment on them, write actual implementation code, test
         the implementations, write documentation and tutorials, or simply use the extensions, and
         report feedback.</para>
      <para>But let's call it a day for the theory, and let's see some real examples using two
         modules: the HTTP Client and the ZIP modules.</para>
   </section>
   <section>
      <title>Two example modules</title>
      <para>Before going to the actual examples, here is a simple introduction to those modules. The
         HTTP Client module, without any surprise, provides the ability to send HTTP requests and
         handle their response. The ZIP module provides ZIP files support, either to read them,
         create new files, or update entries in existing ZIP files.</para>
      <para>The HTTP Client provides one single function: <code>http:send-request</code> (actually
         it defines four different arities for this function, but this is mainly a convenient way to
         pass some values as separate parameters.) This function has been inspired from the
         corresponding XProc step, <code>p:http-request</code>. This function makes it possible to
         query REST services, Google services, Web services through SOAP, or simply to retrieve
         resources on the Web. The signature of this function (of its one-parameter version)
         is:</para>
      <programlisting>
http:send-request($request as element(http:request)) as item()+</programlisting>
      <para>Its parameter is an element representing the request. Its structure is like the
         following sample:</para>
      <programlisting>
&lt;http:request href="http://www.example.com/..." method="post">
   &lt;http:header name="X-Header" value="some value"/>
   &lt;http:body content-type="application/xml">
      &lt;hello>World!&lt;/hello>
   &lt;/http:body>
&lt;/http:request></programlisting>
      <para>The previous request will result in a HTTP POST, with Content-Type
            <code>application/xml</code>, sent to the specified URI and with a header explicitly set
         by the user (<code>X-Header: some value</code>.) The result is described with another
         element, <code>http:response</code>, that describes the response returned by the
         server:</para>
      <programlisting>
&lt;http:response status="200" message="OK">
   &lt;http:header name="..." value="..."/>
   ...
   &lt;http:body content-type="application/xml"/>
&lt;/http:request></programlisting>
      <para>The structure of this element is very similar to the request element. Instead of the URI
         to send the request to and the HTTP method to use, it contains the status code and the
         message returned by the HTTP server. One significant difference is in the way the response
         body is returned. Opposed to the request, the response's body element (if any) is only a
         description of the body. The body content itself is returned as a subsequent item in the
         result sequence (or several items in case of a multipart response.) Let's analyse a sample
         of use, in XQuery:</para>
      <programlisting>
http:send-request(
   &lt;http:request href="http://www.balisage.net/" method="get"/>)</programlisting>
      <para>This simply send a GET request to the web server of Balisage. The result of this
         function call is a sequence of two items: the <code>http:result</code> element and the body
         content as a document node (holding an XHTML document):</para>
      <programlisting>
&lt;http:response status="200" message="OK">
   &lt;http:header name="Server" value="Apache/1.3.41 (Unix)"/>
   ...
   &lt;http:body content-type="text/html"/>
&lt;/http:response>

&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
   &lt;head>
      &lt;title>Balisage: The Markup Conference&lt;/title>
      ...</programlisting>
      <para>This can sound strange to have a sequence as the result of the function, but this is the
         only way to provide the response description along side the payload expressed as a full
         document node. That's a design choice as it prevent to mix different layers in the same
         document. Depending on the content-type returned by the server, the body content is
         analyzed differently. If the content type is an XML type, it is parsed and returned as a
         document node; if it is an HTML type, it is tidied up, parsed and returned as a document
         node; if it is a textual type, it is returned as a string; in any other case, it is
         returned as a <code>xs:base64Binary</code> item. A multipart response will apply this rule
         for each part, and return each part as a subsequent item after the
            <code>http:response</code> element.</para>
      <para>The ZIP module defines the following functions to read the structure of a ZIP file, to
         create a completely new ZIP file from scratch, and to create a new ZIP file, based on an
         existing file by changing only some entries:</para>
      <programlisting>
zip:entries($href) as element(zip:file)
zip:zip-file($zip as element(zip:file)) as empty-sequence()
zip:update-entries($zip, $output) as empty-sequence()</programlisting>
      <para>The first function takes a ZIP file's URI as parameter, and returns a description of its
         structure (its entries) as a <code>zip:file</code> element. This element looks like the
         following:</para>
      <programlisting>
&lt;zip:file href="some.zip">
   &lt;zip:entry name="file.xml"/>
   &lt;zip:entry name="index.html"/>
   &lt;zip:dir name="dir">
      &lt;zip:entry name="file.txt"/>
   &lt;/zip:dir>
&lt;/zip:file></programlisting>
      <para>Only the structure is returned, not the whole content of each file entry. The function
            <code>zip:zip-file()</code> takes a similar element as parameter, and create a new ZIP
         file based on that content. The element is similar, but in addition it contains the content
         of each file entry, so the function has all the needed information to actually create the
         whole file. For each <code>zip:entry</code>, the content of the element can be an XML
         document, a string, or binary encoded as a base 64 string (an attribute tells if the
         content has to be serialized as XML, HTML, text or binary.) An existing file can also be
         copied verbatim to the entry, by giving its URI instead of the actual content. An example
         of a <code>zip:file</code> element to pass to this function is:</para>
      <programlisting>
&lt;zip:file href="some.zip">
   &lt;zip:entry name="file.xml" output="xml">
      &lt;hello>World!&lt;/hello>
   &lt;/zip:entry>
   &lt;zip:entry name="index.html" href="/some/file.html"/>
   &lt;zip:dir name="dir">
      &lt;zip:entry name="file.txt" output="text">
         Hello, world!
      &lt;/zip:entry>
   &lt;/zip:dir>
&lt;/zip:file></programlisting>
      <para>The third function, <code>zip:update-entries()</code>, is looks a lot like
            <code>zip:zip-file()</code>, but it uses an existing ZIP file to create a new one,
         replacing the entries in the <code>zip:file</code> element in parameter. This is then
         possible to use a pattern file, replacing only a few entries, using content computed in
         this expression. To be complete, the module provides also 4 functions to read one specific
         entry from an existing ZIP file, for instance depending on the result of
            <code>zip:entries()</code>. They return either a document node, a string or a
            <code>xs:base64Binary</code> item, following the same rules than
            <code>http:send-request()</code>:</para>
      <programlisting>
zip:xml-entry($href, $entry) as document-node()
zip:html-entry($href, $entry) as document-node()
zip:text-entry($href, $entry) as xs:string
zip:binary-entry($href, $entry) as xs:base64Binary</programlisting>
   </section>
   <section>
      <title>SOAP Web service sample</title>
      <para>EXPath works at the XPath level. But XPath is never used standalone, always from a host
         language. Among the various languages providing support for XPath, XSLT and XQuery have a
         place of choice, by their close integration with XPath. I will then use them to show
         complete samples of use of the functions introduced here. The ability of XQuery to create
         elements directly within expressions make the examples very concise. When transforming XML
         trees is fully part of the example, XSLT makes maybe more sense.</para>
      <para>The first sample consumes a SOAP Web service. The Web service takes as input an element
         with a country code and a city name, and return an element with a corresponding place name
         and the weather forecasting for this place for the next days. The format of the request and
         response elements is:</para>
      <programlisting>
&lt;tns:weather-by-city-request>
   &lt;tns:city>Montreal&lt;/tns:city>
   &lt;tns:country>CA&lt;/tns:country>
&lt;/tns:weather-by-city-request>

&lt;tns:weather-by-city-response>
   &lt;tns:place>Montreal, CA&lt;/tns:place>
   &lt;tns:detail>
      &lt;tns:day>2009-04-21&lt;/tns:day>
      &lt;tns:min-temp>16&lt;/tns:min-temp>
      &lt;tns:max-temp>23&lt;/tns:max-temp>
      &lt;tns:desc>Some useful description.&lt;/tns:desc>
   &lt;/tns:detail>
   &lt;tns:detail>
   ...
&lt;/tns:weather-by-city-response></programlisting>
      <para>The XQuery module thus has to send a SOAP request to the Web service HTTP endpoint, to
         check the error conditions and to use the result content if everything went fine. Those
         steps fit naturally into three different functions defined within the XQuery module. After
         a few declarations (importing the HTTP Client module, declaring namespaces and variables,)
         the three functions are defined and then composed together:</para>
      <programlisting>
xquery version "1.0";

import module namespace http = "http://www.expath.org/mod/http-client";

declare namespace soap = "http://schemas.xmlsoap.org/soap/envelope/";
declare namespace tns  = "http://www.webservicex.net";

declare variable $endpoint as xs:string    := "http://www.webservicex.net/WeatherForecast.asmx";
declare variable $soap-action as xs:string := "http://www.webservicex.net/GetWeatherByPlaceName";

declare function local:send-message()
      as item()+
{
   http:send-request(
      &lt;http:request method="post" href="{ $endpoint }">
         &lt;http:header name="SOAPAction" value="{ $soap-action }"/>
         &lt;http:body content-type="text/xml">
            &lt;soap:Envelope>
               &lt;soap:Header/>
               &lt;soap:Body>
                  &lt;tns:weather-by-city-request>
                     &lt;tns:city>Brussels&lt;/tns:city>
                     &lt;tns:country>BE&lt;/tns:country>
                  &lt;/tns:weather-by-city-request>
               &lt;/soap:Body>
            &lt;/soap:Envelope>
         &lt;/http:body>
      &lt;/http:request>
   )
};

declare function local:extract-payload($res as item()+)
      as element(tns:weather-by-city-response)
{
   let $status := xs:integer($res[1]/@status)
   let $weather := $res[2]/soap:Envelope/soap:Body/*
      return
         if ( $status ne 200 ) then
            error(xs:QName('ERRSOAP001'),
                  concat('HTTP error: ', $status, ' - ', $res[1]/@message))
         else if ( empty($weather) ) then
            error(xs:QName('ERRSOAP002'), "SOAP payload is empty?")
         else
            $weather
};

declare function local:format-result($weather as element(tns:weather-by-city-response))
      as xs:string
{
   string-join((
      'Place: ', $weather/tns:place, '&amp;#10;',
      for $d in $weather/tns:detail return $d/concat(
         '  - ', tns:day, ':&amp;#09;', tns:min-temp, ' - ',
         tns:max-temp, ':&amp;#09;', tns:desc, '&amp;#10;'
      )
    ),
   '')
};

let $http-res := local:send-message()
let $payload  := local:extract-payload($http-res)
   return
      local:format-result($payload)</programlisting>
      <para>If everything goes well, the result should look like the following:</para>
      <programlisting>
Place: Brussels, BE
  - 2009-04-21:  10 - 38:  Sunny, oh sunny!
  - 2009-04-22:  1 - 8:    You cannot have sun twice in Brussels...</programlisting>
      <para>EXAMPLE OF USE OF THE WSDL-COMPILER...</para>
   </section>
</article>

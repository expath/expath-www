<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Web Application</title><link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/base.css" /><style type="text/css">
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }


div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

      code.function { font-weight: bold; }
      code.type { font-style: italic; }
      /* h1, h2, h3 { color: #84001C; background: white } */
      /* a, :link, :visited, a:active { color: #84005C; background: white } */
      body {
        background-image: url(http://expath.org/images/logo-candidate.png);
      }
   </style></head><body><p><a href="http://expath.org/"><img src="http://expath.org/images/expath-icon.png" alt="EXPath" height="32" width="32" /></a></p><div class="head">
<h1><a name="title" id="title"></a>Web Application</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>EXPath Candidate Module 18 March 2013</h2><dl><dt>This version:</dt><dd>
         <a href="http://expath.org/spec/webapp/editor">http://expath.org/spec/webapp/editor</a>
      </dd><dt>Editor:</dt><dd>Florent Georges, <a href="http://h2oconsulting.be/">H2O Consulting</a></dd></dl><p>This document is also available in these non-normative formats: <a href="http://expath.org/spec/webapp/editor.xml">XML</a>.</p><p class="copyright"></p></div><hr /><div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2><p>This specification defines how to write web applications on server-side, using XML
            technologies like XSLT, XQuery and XProc. It also defines their execution context, as
            well as some functions they can use. Last but not least it defines how to package such
            webapps, by using the <a href="#pkg">[EXPath Packaging System]</a>.</p></div><div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2><p class="toc">1 <a href="#intro">Introduction</a><br />
    1.1 <a href="#d3e58">Namespace conventions</a><br />
2 <a href="#containers">Containers and webapps</a><br />
3 <a href="#req-resp">Requests and responses</a><br />
    3.1 <a href="#requests">Requests</a><br />
    3.2 <a href="#responses">Responses</a><br />
4 <a href="#components">Components</a><br />
    4.1 <a href="#xproc">XProc</a><br />
    4.2 <a href="#xquery">XQuery</a><br />
    4.3 <a href="#xslt">XSLT</a><br />
5 <a href="#apps">Applications</a><br />
    5.1 <a href="#context-root">Context root</a><br />
    5.2 <a href="#servlets">Servlets</a><br />
    5.3 <a href="#resources">Resources</a><br />
    5.4 <a href="#filters">Filters</a><br />
    5.5 <a href="#error-handling">Error handling</a><br />
    5.6 <a href="#chains">Chains</a><br />
    5.7 <a href="#groups">Groups</a><br />
    5.8 <a href="#config">Config</a><br />
6 <a href="#descriptor">Webapp descriptor</a><br />
7 <a href="#functions">Webapp functions</a><br />
    7.1 <a href="#fields">Fields</a><br />
    7.2 <a href="#parse">Parse HTTP</a><br />
8 <a href="#todo">TODO list</a><br />
9 <a href="#examples">Examples (notes)</a><br />
</p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3><p class="toc">A <a href="#expath-pkg.xsd">Webapp schema</a><br />
B <a href="#references">References</a><br />
</p></div><hr /><div class="body"><div class="div1">
<h2><a name="intro" id="intro"></a>1 Introduction</h2><p>Bla bla bla</p><div class="div2">
<h3><a name="d3e58" id="d3e58"></a>1.1 Namespace conventions</h3><p>The webapp descriptor uses the namespace <code>http://expath.org/ns/webapp</code>, as
               the default namespace. This namespace is also used for the XML representation of the
               HTTP requests and responses, and to define several functions provided by the webapp
               container. In this document, the <code>web</code> prefix, when used, is bound to this
               namespace URI.</p><p>Error codes are defined in the namespace <code>http://expath.org/ns/error</code>. In
               this document, the <code>err</code> prefix, when used, is bound to this namespace
               URI.</p></div></div><div class="div1">
<h2><a name="containers" id="containers"></a>2 Containers and webapps</h2><p>A web application, or webapp, in this specification, is a set of components,
            implementing an application. The application responds to HTTP requests and runs in a
            webapp container. The container provides the context of execution for the webapps,
            provides them with some functions, and is responsible for translating from and to HTTP.
            When the container receives an HTTP request, it identifies the corresponding component
            to process it (e.g. based on the request URL), builds an XML representation of the
            request, and call the component. The component receives the HTTP request as an XML
            document, and returns an XML description of the HTTP response to send back to the
            client. The container then translates this XML document and actually send the
            corresponding HTTP response.</p><p>A component is a piece of XSLT, XQuery or XProc. Each type of component defines how the
            request is passed to and the response is returned by such a component. But the XML
            format of the requests and responses is always the same. The existing types of
            components are:</p><ul><li><p>an XSLT stylesheet</p></li><li><p>an XSLT function</p></li><li><p>an XSLT template</p></li><li><p>an XQuery query</p></li><li><p>an XQuery function</p></li><li><p>an XProc pipeline</p></li><li><p>an XProc step</p></li></ul><p>A webapp contains a descriptor, which defines how to dispatch a request to a specific
            component. The dispatching mechanism is based on the request URL, by associating a URL
            pattern to a component public URI (a component public URI is defined in the <a href="#pkg">[EXPath Packaging System]</a>, basically it is the component name, as an absolute URI). The association
            of a URL pattern to a component is called a servlet. Every servlet has a name.</p><p>A webapp is installed at a specific context root. The context root is a path prefix, and
            all the request received "below" that prefix are served by that webapp. For instance, a
            webapp installed on example.org at the context root /somewhere will serve all requests
            with a URL starting with <code>http://example.org/somewhere/</code>. The part after that
            prefix is the path to the servlet.</p></div><div class="div1">
<h2><a name="req-resp" id="req-resp"></a>3 Requests and responses</h2><p>The HTTP requests and responses are represented as XML documents. The request is build
            by the container to represent the actual HTTP request received. The component returns a
            representation of the response, used by the container to actually respond to the client
            over HTTP. A sample request:</p><div class="exampleInner"><pre>
&lt;request servlet="some" path="/some/resource" method="get" xmlns="http://expath.org/ns/webapp"&gt;
   &lt;url&gt;http://example.org/myapp/some/resource&lt;/url&gt;
   &lt;authority&gt;http://example.org&lt;/authority&gt;
   &lt;context-root&gt;/myapp&lt;/context-root&gt;
   &lt;path&gt;
      &lt;part&gt;/some/&lt;/part&gt;
      &lt;match name="rsrc"&gt;resource&lt;/match&gt;
   &lt;/path&gt;
   &lt;header name="host" value="example.org"/&gt;
   &lt;header name="user-agent" value="Firefox/7.0.1"/&gt;
   &lt;header name="accept" value="text/html,application/xml;q=0.9,*/*;q=0.8"/&gt;
   &lt;header name="accept-language" value="en-us,en;q=0.5"/&gt;
&lt;/request&gt;
</pre></div><p>This request can be build by a container listening at http://example.org/, when received
            a request to GET the resource at /myapp/some/resource. We can see the path has been
            pre-analyzed, and the request contains various HTTP information like the method, the
            request URL (decomposed in different ways), and the headers. The request might also
            contain an entity content, also known as the body of the request (e.g. in case of a PUT
            request).</p><p>In response to the above request, the invoked component could return the following
            response to the container:</p><div class="exampleInner"><pre>
&lt;response status="200" message="Ok" xmlns="http://expath.org/ns/webapp"&gt;
   &lt;header name="X-My-Header" value="Just an example."/&gt;
   &lt;body content-type="application/xml"&gt;
      &lt;hello&gt;World!&lt;/hello&gt;
   &lt;/body&gt;
&lt;/response&gt;
</pre></div><p>This tells the container to return the XML document
               <code>&lt;hello&gt;World!&lt;/hello&gt;</code> to the client, using the Content-Type
            "application/xml", with the HTTP status code 200, and an extra header.</p><div class="div2">
<h3><a name="requests" id="requests"></a>3.1 Requests</h3><p>A HTTP requet is represented by a sequence, the <em>request sequence</em>. The
               first item in that sequence is an element <code>web:request</code>, remaining items
               representing the entity content (there might be several of them in case of
               multipart). The web:request element is defined as the following:</p><div class="exampleInner"><pre>
&lt;request servlet = NCName
         path = string
         method = NCName&gt;
   url,
   authority,
   context-root,
   path,
   param*,
   header*,
   (body|
    multipart)?
&lt;/request&gt;
</pre></div><p>A request contains the name of the matched <code>servlet</code>, the request
                  <code>path</code>, and its <code>method</code> (also known as the HTTP verb, like
               GET and POST) in lower case. The text element <code>url</code> contains the original
               request URL, including its query parameters if any. The URL also appears cut down
               into several pieces. The element <code>authority</code> is its first part, including
               the URL scheme and the domain name, <code>context-root</code> is the webapp context
               root, <code>path</code> is an alternative representation of the requested path (as in
               the attribute <code>path</code>), where some specific parts have been analyzed, and
               the elements <code>param</code> represent the query parameters.</p><p>Then come the HTTP <code>header</code> elements, each with a name and a value. Then
               the content of the HTTP entity (e.g. for a PUT), as an element <code>body</code> or
                  <code>multipart</code>, depending on the content type of the request.</p><div class="exampleInner"><pre>
&lt;header name = string
        value = string&gt;
   <em>empty</em>
&lt;header&gt;
</pre></div><p><b>URL</b></p><p>The URL appears at several places in the request element, under different shapes. The
               element <code>url</code> is the original URL as typed by the user. Or at least it is
               an educated guess of what it could be, as HTTP does not include the original URL in
               the request (the port number for instance is not in the HTTP request).</p><p>The element <code>authority</code> is the first part of the URL, including the URL
               scheme and the domain name (up to the slash first, but not including it). The scheme
               can be either "http:" or "https:". It is then followed by two slashes then the domain
               name.</p><p>The element <code>context-root</code> is the webapp context root on this server. It
               is fixed for the webpp, and represents where the webapp has been "installed" on the
               server (the webapp serves all requests coming to URLs "below" its context root).</p><p>After the element <code>path</code> (see below), the query parameters, if any, are
               represented each with an element <code>param</code>, with an attribute
                  <code>name</code> and an attribute <code>value</code>.</p><div class="exampleInner"><pre>
&lt;param name = string
       value = string&gt;
   <em>empty</em>
&lt;param&gt;
</pre></div><p>Note that the XPath expression "<code>fn:concat(authority, context-root,
               path)</code>" gives the original URL except the query parameters.</p><p><a id="path" name="path"></a><b>Path</b></p><p>The path is the part of the request URL that comes after the context root (excluding
               the query parameters). This is thus the part that can vary for a given webapp (for a
               given webapp, deployed on a specific server at a specific context root, everything up
               to and including the context root will be always the same). Servlets use regexes to
               match URLs, and they can give a name to some sub parts of the path matched by the
               regex (see the definition of the webapp descriptor for all details).</p><p>This is represented by having, in the element <code>path</code>, a sequence of
               elements <code>part</code> and <code>match</code>. The elements <code>part</code> are
               the non-matched parts of the URL, and the elements <code>match</code> are the matched
               parts of the URL. They appear in the same order as in the URL.</p><div class="exampleInner"><pre>
&lt;path&gt;
   (part|
    match)+
&lt;/path&gt;

&lt;part&gt;
   <em>string</em>
&lt;/part&gt;

&lt;match name = NCName&gt;
   <em>string</em>
&lt;/part&gt;
</pre></div><p>The entire path is the string value of the element <code>path</code>. Put another
               way, concatenating all the <code>part</code> and <code>match</code> elements, in
               order, gives the value of the path. It is also available as the value of the
               attribute <code>path</code> on the element <code>request</code>. See <a href="#servlets"><b>5.2 Servlets</b></a> for an example.</p><p><b>Content</b></p><p>The body of the request, in HTTP parlance the entity content, is not embedded in the
               XML element representing the request (that is the web:request element). It is instead
               represented as a standalone item in the sequence representing the request. There
               might be several items in case of multipart. Each item can be of one of the following
               types:</p><ul><li><p>a document node in case of an XML or HTML media type</p></li><li><p>an xs:string in case of an textual media type</p></li><li><p>an xs:base64Binary in case of any other media type</p></li></ul><p>Selecting the media part is done based on the Content-Type header. In case of a
               multipart type, each part is represented by its own item. Each part's pseudo header
               Content-Type is used the same way that the header Content-Type is used for the entire
               content in case of a single part. The content type is used as follows:</p><ul><li><p>An XML media type has a MIME type of <code>text/xml</code>,
                     <code>application/xml</code>, <code>text/xml-external-parsed-entity</code>, or
                     <code>application/xml-external-parsed-entity</code>, as defined in <a href="#rfc3023">[RFC 3023]</a> (except that <code>application/xml-dtd</code> is considered a
                     text media type). MIME types ending by <code>+xml</code> are also XML media
                     types.</p></li><li><p>An HTML media type has a MIME type of <code>text/html</code>. The precise
                     algorithm to parse HTML into an XDM document node is
                     implementation-defined.</p></li><li><p>Text media types are the remaining types beginning with <code>text/</code>.</p></li><li><p>Binary types are all the other types. An implementation can treat some of those
                     binary types as either an XML, HTML or text media type if it is more
                     appropriate (this is implementation-defined).</p></li></ul><p>If the content type is <code>text/html</code>, the content is parsed into an XDM
               document node (using some HTML parsing algorithm that is out of the scope of this
               specification). If the content type is <code>application/xml</code>, or
               <code>text/xml</code>, or ends with <code>+xml</code>, </p><p>The content itself is represented as additional items in the request sequence, but
               for each part, there is a <code>web:body</code> element in the
               <code>web:request</code> element, describing the part. In case of multipart, the
               <code>web:body</code> elements are wrapped into a <code>web:multipart</code> element.
               In case of no mutipart, there is one <code>web:body</code> element, direct child of
               <code>web:request</code>:</p><div class="exampleInner"><pre>
&lt;multipart&gt;
   (header*,
    body)+
&lt;/multipart&gt;

&lt;header body = integer
        name = string
        value = string&gt;
   <em>empty</em>
&lt;header&gt;

&lt;body position = integer
      content-type = string&gt;
   <em>empty</em>
&lt;body&gt;
</pre></div><p>The attribute <code>position</code> is the position of the body in a multipart (1, 2,
               3...) In case if a single part, it is always 1. The pseudo headers for each part in a
               multipart are before the part they relate to. Their attribute <code>body</code> also
               contains the corresponding body position. It is therefore possible to use either
               positional grouping (all the consecutive <code>web:header</code> elements right
               before a <code>web:body</code> element relates to this one), or value-based grouping
               (the <code>web:header</code> elements relate to the <code>web:body</code> element
               with the same position number). The body position number is also the position of the
               corresponding content in the request sequence (the <code>web:request</code> element
               is the first item, then comes the body #1, then the body #2, and so on).</p><p>Note that the <code>web:header</code> elements that are children of a
               <code>web:multipart</code> have the same structure as when they are children of
               <code>web:request</code>, except they have the extra attribute <code>body</code>.</p></div><div class="div2">
<h3><a name="responses" id="responses"></a>3.2 Responses</h3><p>When invoked, the top-level component (or group, or filter, if any) must return a
               sequence, the <em>response sequence</em>. The first item must be an element
               <code>web:response</code>, the remaining items being the content of the response to
               sent back to the client.</p><div class="exampleInner"><pre>
&lt;response status = integer
          message = string&gt;
   header*,
   (body|
    multipart)?
&lt;/response&gt;
</pre></div><p>The attribute <code>status</code> is the HTTP status code, and the attribute
               <code>message</code> is the HTTP status message. The elements <code>web:header</code>
               represent HTTP header to set in the response, and look like the same elements in the
               request.</p><div class="exampleInner"><pre>
&lt;multipart&gt;
   (header*,
    body)+
&lt;/multipart&gt;

&lt;body item-position = integer?
      charset = string?
      content-type = string&gt;
   <em>optional content</em>
&lt;/body&gt;
</pre></div><p>The elements <code>web:multipart</code> and <code>web:body</code> represent the
               content to send back to the client, in a similar way as they are represented by the
               container in the request. The difference is that the pseudo-headers do not have an
               attribute <code>body</code>, the elements <code>web:body</code> do noy have an
               attribute <code>position</code>, and they might have an attribute
               <code>charset</code> and an attribute <code>item-position</code>, and they might have
               content. The content and <code>item-position</code> are mutually exclusive. If none
               of them is present, the body is empty. <code>charset</code> is the character
               encoding, for non-binary media types, and is UTF-8 by default.
               <code>item-position</code> is the position within the response sequence of the item
               representing the content of the correpsonding part, after the
               <code>web:response</code> element (that is, the first item after the response
               element, which is the second item in the sequence, has the position 1, the next one
               the position 2, and so on).</p></div></div><div class="div1">
<h2><a name="components" id="components"></a>4 Components</h2><p>A component is a piece of code, written in one of the supported languages, that is
            executed in some specific context. For instance in response to a HTTP request, or as the
            action associated to a filter. A component must follow a few rules (for instance the
            number or name of parameters), so the web container can call it. A component is declared
            in the webapp descriptor. The format of the webapp descriptor is defined in the section
            <a href="#descriptor"><b>6 Webapp descriptor</b></a>, but the corresponding config for each single type of
            component is described here in more detail.</p><p>The webapp itsef is packaged as a standard EXPath package (see <a href="#pkg">[EXPath Packaging System]</a>).
            Each component must be identifiable through the package descriptor (e.g. an XSLT
            stylesheet must have a public import URI condigured in the package, or the namespace of
            the XQuery library module containing the function used as a component must be declared
            in the package as well).</p><div class="div2">
<h3><a name="xproc" id="xproc"></a>4.1 XProc</h3><p>An XProc component can be a pipeline, identified by its public import URI:</p><div class="exampleInner"><pre>
&lt;xproc uri="http://example.org/ns/my-webapp/pipeline.xproc"/&gt;
</pre></div><p>An XProc component can also be a step type, identified by its QName:</p><div class="exampleInner"><pre>
&lt;xproc uri="http://example.org/ns/my-webapp/step-library.xproc"
       step="app:my-step"/&gt;
</pre></div><p>The prefix used in the <code>step</code> attribute must be declared in scope (in the
               example above, the prefix <code>app</code> must be bound to the namespace of the
               step).</p><p>Both pipelines and steps must have one input port named <code>source</code>, which
               accepts a sequence of documents, and one output port named <code>result</code>, which
               might return a sequence of documents. When used as an error handler, they must have
               an input port called <code>user-data</code>, which must accepts a sequence of
               documents (only of the application use the user data feature of error reporting, to
               pass any data from where the error is thrown to the error handler, see <a href="#error-handling"><b>5.5 Error handling</b></a> for details).</p><p>The following is a simple example of a pipeline, returning the XML representation of
               the HTTP request as the response itself:</p><div class="exampleInner"><pre>
&lt;p:declare-step xmlns:p="http://www.w3.org/ns/xproc"
                xmlns:web="http://expath.org/ns/webapp"
                xmlns:app="http://example.org/ns/my-webapp"
                xmlns:pkg="http://expath.org/ns/pkg"
                pkg:import-uri="http://example.org/my-webapp/echo.xproc"
                name="main"
                version="1.0"&gt;

   &lt;p:input  port="source" primary="true" sequence="true"/&gt;
   &lt;p:output port="result" primary="true" sequence="true"&gt;
      &lt;p:pipe step="response" port="result"/&gt;
      &lt;p:pipe step="main"     port="source"/&gt;
   &lt;/p:output&gt;

   &lt;!--
      Echoes the web:request element, ignores the bodies if any.
   --&gt;

   &lt;p:identity name="response"&gt;
      &lt;p:input port="source"&gt;
         &lt;p:inline&gt;
            &lt;web:response status="200" message="Ok"&gt;
               &lt;web:body content-type="application/xml"/&gt;
            &lt;/web:response&gt;
         &lt;/p:inline&gt;
      &lt;/p:input&gt;
   &lt;/p:identity&gt;

&lt;/p:declare-step&gt;
</pre></div></div><div class="div2">
<h3><a name="xquery" id="xquery"></a>4.2 XQuery</h3><p>An XQuery component can be a main module (also called a "query"), identified by its
               public import URI:</p><div class="exampleInner"><pre>
&lt;xquery uri="http://example.org/ns/my-webapp/query.xq"/&gt;
</pre></div><p>An XQuery component can also be a function, identified by its QName:</p><div class="exampleInner"><pre>
&lt;xquery function="app:my-function"/&gt;
</pre></div><p>The prefix used in the <code>function</code> attribute must be declared in scope (in
               the example above, the prefix <code>app</code> must be bound to the namespace of the
               function). Because the XQuery library modules are identified by their target
               namespace in the package descriptor, the name of the function itself is enough to
               identify uniquely the function.</p><p>The request sequence (containing the <code>web:request</code> element and the request
               bodies) is passed to the XQuery function through its only parameter, and to the
               XQuery module through the external variable named <code>$web:input</code> (the
               <code>web:request</code> element is also set as the context element for evaluating
               the query).</p><p>The following is a simple example of a function, returning the XML representation of
               the HTTP request as the response itself:</p><div class="exampleInner"><pre>
xquery version "1.0";

module namespace app = "http://example.org/ns/my-webapp";

(:~
 : Echoes the web:request element, ignores the bodies if any.
 :)
declare function app:echo($input as item()+) as element()+
{ 
   &lt;web:response status="200" message="Ok"&gt;
      &lt;web:body content-type="application/xml"/&gt;
   &lt;/web:response&gt;
   ,
   $input[1]
};
</pre></div></div><div class="div2">
<h3><a name="xslt" id="xslt"></a>4.3 XSLT</h3><p>An XSLT component can be a stylesheet, identified by its public import URI:</p><div class="exampleInner"><pre>
&lt;xslt uri="http://example.org/ns/my-webapp/stylesheet.xsl"/&gt;
</pre></div><p>An XSLT component can also be a named template, identified by its QName:</p><div class="exampleInner"><pre>
&lt;xslt uri="http://example.org/ns/my-webapp/stylesheet.xsl"
      template="app:my-template"/&gt;
</pre></div><p>An XSLT component can also be a function, identified by its QName:</p><div class="exampleInner"><pre>
&lt;xslt uri="http://example.org/ns/my-webapp/stylesheet.xsl"
      function="app:my-function"/&gt;
</pre></div><p>The prefix used in both the <code>function</code> and <code>template</code>
               attributes must be declared in scope (in both examples above, the prefix
               <code>app</code> must be bound to the namespace of the template, or of the function
               resp.)</p><p>The request sequence (containing the <code>web:request</code> element and the request
               bodies) is passed to the XSLT function through its only parameter, to the named
               template through the template parameter named <code>web:input</code>, and to the
               stylesheet through the global parameter named <code>web:input</code> (the
               <code>web:request</code> element is also set as the context element for evaluating
               the stylesheet).</p><p>The following is a simple example of a stylesheet, returning the XML representation
               of the HTTP request as the response itself:</p><div class="exampleInner"><pre>
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:pkg="http://expath.org/ns/pkg"
                xmlns:web="http://expath.org/ns/webapp"
                exclude-result-prefixes="#all"
                version="2.0"&gt;

   &lt;pkg:import-uri&gt;http://example.org/ns/my-webapp/echo.xsl&lt;/pkg:import-uri&gt;

   &lt;xsl:template match="/"&gt;
      &lt;web:response status="200" message="Ok"&gt;
         &lt;web:body content-type="application/xml"/&gt;
      &lt;/web:response&gt;
      &lt;xsl:sequence select="."/&gt;
   &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div></div></div><div class="div1">
<h2><a name="apps" id="apps"></a>5 Applications</h2><p>An application (sometimes refered to as a webapp) is described by the webapp descriptor,
            and is composed of servlets, resources and filters, which can be grouped together,
            declares error handlers, and provides access to some configuration. An application is
            deployed within a web container, and has a dedicated context root.</p><div class="div2">
<h3><a name="context-root" id="context-root"></a>5.1 Context root</h3><p>When deployed into a web container, a webapp is assigned a context root. A context
               root is an absolute URL, which is the root of all URLs served by the webapp. That is,
               all URLs served by the webapp start with the same substring: the context root. For
               instance, if a webapp is deployed at <code>http://example.org/myapp/</code>, that
               means that all URLs starting with the same string will be dispatched by the container
               to that webapp, for instance:</p><ul><li><p><code>http://example.org/myapp/</code></p></li><li><p><code>http://example.org/myapp/index.html</code></p></li><li><p><code>http://example.org/myapp/catalog/item/XYZ123</code></p></li><li><p><code>http://example.org/myapp/catalog/item/XYZ123/buy</code></p></li><li><p><code>http://example.org/myapp/search?q=brussels%20hotels</code></p></li></ul><p>Until deployed, a webapp has no context root. All URLs defined within the webapp are
               either relative, or absolute (starting with "<code>/</code>"). When absolute, they
               are relative to the context root. For instance, a webapp handling the above URLs will
               define how to serve the following URLs:</p><ul><li><p><code>/</code></p></li><li><p><code>/index.html</code></p></li><li><p><code>/catalog/item/XYZ123</code></p></li><li><p><code>/catalog/item/XYZ123/buy</code></p></li><li><p><code>/search?q=brussels%20hotels</code></p></li></ul><p>If this webapp is deployed at the above context root, it will then serve the defined
               URLs. But it can also be deployed on localhost, for instance for test or dev
               purposes. The set of URLs served by the webapp will be different then, but the set of
               URLs served, when they are relative to the context root, are the same for a same
               webapp.</p></div><div class="div2">
<h3><a name="servlets" id="servlets"></a>5.2 Servlets</h3><p>A servlet is the association of a URL pattern to a component. A servlet can be given
               a name as well, for documentation and error reporting purposes. A servlet is
               configured in the webapp descriptor like the following:</p><div class="exampleInner"><pre>
&lt;servlet name = NCName?
         filters = NCNames?&gt;
   <em>component</em>,
   url
&lt;/servlet&gt;

&lt;url pattern = string&gt;
   match*
&lt;/url&gt;

&lt;match group = integer
       name = NCName&gt;
   <em>empty</em>
&lt;/match&gt;
</pre></div><p>The attribute <code>name</code> is the optional name of the servlet. The attribute
               <code>filters</code> is a space-separated list of NCNames, explained in <a href="#filters"><b>5.4 Filters</b></a>. The pseudo element <em><code>component</code></em> is any of the
               existing component types defined in <a href="#components"><b>4 Components</b></a>, that is either
               <code>xproc</code>, <code>xquery</code> or <code>xslt</code> (any of their variants).
               The attribute <code>pattern</code> must be a valid XML Schema regular expression
               (TODO: add a reference to the spec), matching a string starting with
               "<code>/</code>".</p><p>When a HTTP request hits the web container, it identifies the webapp to serve the
               request (depending on their context roots; that mechanism is implementation-defined).
               Then it tries to match the request URL against all URL patterns in the webapp
               descriptor, is sequence in the document order, and picks the first servlet with a URL
               pattern matching the request URL. The corresponding component is executed, by passing
               the request sequence, and the result of the servlet is used to return a response to
               the client.</p><p>The elements <code>match</code> of the matching URL are linked to the regex groups in
               the URL pattern. Because the URL pattern is a regex, matching against it can assign
               values to groups (by using parenthesis in the regex). The element <code>match</code>
               assigns a symbolic name to a group number. The corresponding values are put into the
               <code>web:request</code> element, more precisely in its child element
               <code>web:path</code>. For example the following servlet definition, associating an
               XSLT stylesheet component to a URL pattern, and naming some specific parts of the
               URL:</p><div class="exampleInner"><pre>
&lt;servlet name="user"&gt;
   &lt;xslt uri="http://example.org/myapp/users.xsl"/&gt;
   &lt;url pattern="/users/([a-z0-9]+)"&gt;
      &lt;match group="1" name="id"/&gt;
   &lt;/url&gt;
&lt;/servlet&gt;</pre></div><p>will produce the following <code>path</code> element when matching a URL ending with
               <code>/users/fgeorges</code>:</p><div class="exampleInner"><pre>
&lt;path&gt;
   &lt;part&gt;/users/&lt;/part&gt;
   &lt;match name="id"&gt;fgeorges&lt;/match&gt;
&lt;/path&gt;</pre></div></div><div class="div2">
<h3><a name="resources" id="resources"></a>5.3 Resources</h3><p>A resource is a special type of servlet, defined by the following element:</p><div class="exampleInner"><pre>
&lt;resource pattern = string
          rewrite = string?
          media-type = string&gt;
   <em>empty</em>
&lt;/resource&gt;</pre></div><p>The <code>pattern</code> attribute has the same meaning as for <code>servlet</code>.
               A resource is a servlet, so when the URL dispatcher looks sequentially through the
               URL patterns for a match, that includes resources as well. If a resource matches the
               URL and has a <code>rewrite</code> attribute, this one is interpreted as a regex
               replacement string, and the path used to be resolved is the result of evaluating the
               following expression, where <code>$url</code> is the actual URL being matched:
               <code>replace($url,@pattern,@rewrite)</code>.</p><p>The resulting path (either the resolved URL or the replaced string if their is a
               <code>rewrite</code> attribute) is then resolved into the application package. If the
               path starts with a slash, this one removed, then the path is resolved against the
               webapp package content directory. The resulting file is the body of the response, the
               value of the <code>media-type</code> attribute is the value of the response header
               Content-Type, and the response status is "<code>200 - OK</code>". If the file does
               not exists, the response status is "<code>400 - Not Found</code>" and the content of
               the response is implementation-defined.</p><p>For instance, the following definitions set the correct Content-Type for CSS
               stylesheets and PNG images, which are resolve in the package in the sub-directories
               <code>style/</code> and <code>images/</code> respectively:</p><div class="exampleInner"><pre>
&lt;resource pattern="/style/.+\.css"  media-type="text/css"/&gt;
&lt;resource pattern="/images/.+\.png" media-type="image/png"/&gt;</pre></div><p>The following example rewrite the URL so <code>/style/print</code> will resolve in
               the webapp package content dir as <code>css/main-print.css</code>:</p><div class="exampleInner"><pre>
&lt;resource pattern="/style/(.+)" rewrite="css/main-$1.css" media-type="text/css"/&gt;</pre></div></div><div class="div2">
<h3><a name="filters" id="filters"></a>5.4 Filters</h3><p>A filter has a name and two components, the "<em>in</em>" and the
               "<em>out</em>" component. Both components are optional, but at least one is
               required:</p><div class="exampleInner"><pre>
&lt;filter name = NCName&gt;
   in?,
   out?
&lt;/filter&gt;

&lt;in&gt;
   <em>component</em>
&lt;/in&gt;

&lt;out&gt;
   <em>component</em>
&lt;/out&gt;</pre></div><p>When a filter is attached to a servlet, the input sequence flowing to the servlet
               first passes to the filter "<em>in</em>" component if any. The input sequence
               becomes the input sequence of the "<em>in</em>" component, and the result of
               evaluating it becomes the input sequence of the servlet component. The result of
               evaluating the servlet component passes then through the filter "<em>out</em>"
               component, if any. The result of the servlet becomes the "<em>out</em>" component
               input sequence, and the result of evaluating it becomes the result returned to the
               container.</p><p>TODO: Explain how to attach a filter to a servlet. Explain here or in <a href="#servlets"><b>5.2 Servlets</b></a>? (because a filter can also be attached through 'group' and
               'application', there are precedence between all them, and there can be error handlers
               as well as filters...)</p></div><div class="div2">
<h3><a name="error-handling" id="error-handling"></a>5.5 Error handling</h3><p>...</p></div><div class="div2">
<h3><a name="chains" id="chains"></a>5.6 Chains</h3><p>...</p></div><div class="div2">
<h3><a name="groups" id="groups"></a>5.7 Groups</h3><p>...</p></div><div class="div2">
<h3><a name="config" id="config"></a>5.8 Config</h3><p>...</p></div></div><div class="div1">
<h2><a name="descriptor" id="descriptor"></a>6 Webapp descriptor</h2><p>TODO: Define the webapp descriptor format, and the relationship with the packaging
            spec.</p></div><div class="div1">
<h2><a name="functions" id="functions"></a>7 Webapp functions</h2><p>Those functions are defined in the namespace <code>web</code>.</p><div class="div2">
<h3><a name="fields" id="fields"></a>7.1 Fields</h3><p>A webapp can access and store values, attached to different contexts: the container,
               the webapp, the session, and the request. The request is the current HTTP request
               being served, the session is the session of the request, the webapp is the one
               containing the component serving the request, and the container represents the webapp
               container as a whole.</p><p>A field has a name (a string) and a value (any sequence). The names beginning with
               "web:" are reserved for this specification. Note that "web:" is not a namespace
               prefix, and then does not need to be bound by any mean, field names are simple
               strings.</p><p>Each set of fields has three corresponding functions: one to get the value of a field
               given its name, one to set its value, and one to enumerate the names of all existing
               fields.</p><p>For the request fields:</p><div class="exampleInner"><pre>
<code class="function">web:get-request-field</code>($name as xs:string) as item()*
<code class="function">web:set-request-field</code>($name as xs:string,
                      $value as item()*) as empty-sequence()
<code class="function">web:get-request-field-names</code>() as xs:string*
</pre></div><p>For the session fields:</p><div class="exampleInner"><pre>
<code class="function">web:get-session-field</code>($name as xs:string) as item()*
<code class="function">web:set-session-field</code>($name as xs:string,
                      $value as item()*) as empty-sequence()
<code class="function">web:get-session-field-names</code>() as xs:string*
</pre></div><p>For the webapp fields:</p><div class="exampleInner"><pre>
<code class="function">web:get-webapp-field</code>($name as xs:string) as item()*
<code class="function">web:set-webapp-field</code>($name as xs:string,
                     $value as item()*) as empty-sequence()
<code class="function">web:get-webapp-field-names</code>() as xs:string*
</pre></div><p>For the container fields:</p><div class="exampleInner"><pre>
<code class="function">web:get-container-field</code>($name as xs:string) as item()*
<code class="function">web:set-container-field</code>($name as xs:string,
                        $value as item()*) as empty-sequence()
<code class="function">web:get-container-field-names</code>() as xs:string*
</pre></div><p>The container contains the following fields:</p><ul><li><p><code>web:xyz</code>: lorem ipsum</p></li><li><p><code>web:abc</code>: bla bla bla</p></li></ul><p>TODO: Define above built-in fields... Get inspiration from the XSLT 2.0 system
               properties...</p></div><div class="div2">
<h3><a name="parse" id="parse"></a>7.2 Parse HTTP</h3><div class="exampleInner"><pre>
<code class="function">web:parse-header-value</code>($header as xs:string) as element(web:header)
</pre></div><p>This function parses the value of a structured HTTP header. It returns it in the form
               of the following element:</p><div class="exampleInner"><pre>
&lt;web:header&gt;
   web:element+
&lt;/web:header&gt;

&lt;web:element name = string&gt;
   web:param*
&lt;/web:element&gt;

&lt;web:param name = string
           value = string&gt;
   <em>empty</em>
&lt;/web:param&gt;
</pre></div><p>For example, the following call:</p><div class="exampleInner"><pre>
web:parse-header-value('text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8')
</pre></div><p>returns the following element:</p><div class="exampleInner"><pre>
&lt;web:header&gt;
   &lt;web:element name="text/html"/&gt;
   &lt;web:element name="application/xhtml+xml"/&gt;
   &lt;web:element name="application/xml"&gt;
      &lt;web:param name="q" value="0.9"/&gt;
   &lt;/web:element&gt;
   &lt;web:element name="*/*"&gt;
      &lt;web:param name="q" value="0.8"/&gt;
   &lt;/web:element&gt;
&lt;/web:header&gt;
</pre></div><p>TODO: Add references to the HTTP spec for the exact format, grammar, and for what
               headers this applies to.</p><div class="exampleInner"><pre>
<code class="function">web:parse-basic-auth</code>($header as xs:string) as element(web:basic-auth)
</pre></div><p>This function parses the value of a Basic Authentication header. It returns it in the
               form of the following element:</p><div class="exampleInner"><pre>
&lt;web:basic-auth username = string
                password = string&gt;
   <em>empty</em>
&lt;/web:basic-auth&gt;
</pre></div><p>The value of the header is "Basic XYZ" where XYZ is "user:password" encoded using
               base64.</p><p>TODO: Add references to the Basic Authentication spec.</p></div></div><div class="div1">
<h2><a name="todo" id="todo"></a>8 TODO list</h2><ul><li><p>Definition: define the name "accessor", to use when I use "URL" as "URL relatively
                  to the context root", for instance for matching against patterns. And use it
                  consistently across the spec.</p></li><li><p>Definition: define the format of various names (servlets, url matches, filters,
                  chains, error handlers, etc.) And use it consistently across the spec. Or do we
                  just use NCName all the time?</p></li></ul></div><div class="div1">
<h2><a name="examples" id="examples"></a>9 Examples (notes)</h2><div class="exampleInner"><pre>
&lt;webapp xmlns="http://expath.org/ns/webapp"
        xmlns:app="http://expath.org/ns/samples/servlex/hello"
        name="http://expath.org/samples/servlex/hello"
        abbrev="hello-world"
        version="0.1.0"&gt;

   &lt;title&gt;Servlex hello-world application&lt;/title&gt;

   &lt;resource pattern="/" rewrite="index.html" media-type="application/xhtml+xml"/&gt;

   &lt;servlet name="xslt"&gt;
      &lt;xslt uri="http://expath.org/ns/samples/servlex/hello.xsl"
            function="app:hello-xslt"/&gt;
      &lt;url pattern="/xslt"/&gt;
   &lt;/servlet&gt;

   &lt;servlet name="xquery"&gt;
      &lt;xquery function="app:hello-xquery"/&gt;
      &lt;url pattern="/xquery"/&gt;
   &lt;/servlet&gt;

   &lt;servlet name="xproc"&gt;
      &lt;xproc uri="http://expath.org/ns/samples/servlex/hello.xproc"/&gt;
      &lt;url pattern="/xproc"/&gt;
   &lt;/servlet&gt;

&lt;/webapp&gt;
</pre></div><p>...</p><div class="exampleInner"><pre>
&lt;webapp name = uri
        abbrev = NCName
        version = string&gt;
   title,
   resource*,
   *** <em>TODO: Add filters, groups, etc.</em> ***
   servlet+
&lt;/webapp&gt;
</pre></div><p>...</p><div class="exampleInner"><pre>
&lt;servlet name? = NCName&gt;
   <em>component</em>,
   url
&lt;/servlet&gt;

&lt;xproc uri = uri
       step? = QName/&gt;

&lt;xquery uri? = uri
        function? = QName/&gt;

&lt;xslt uri = uri
      function? = QName
      template? = QName/&gt;

&lt;url pattern? = URLPattern/&gt;
</pre></div><p>...</p><div class="exampleInner"><pre>
&lt;response status="200" message="Ok" xmlns="http://expath.org/ns/webapp"&gt;
   &lt;header name="Content-Disposition" value="filename=the-file.txt"/&gt;
   &lt;body content-type="application/zip" src="/some/path/to/the/file.txt"/&gt;
&lt;/response&gt;
</pre></div></div></div><div class="back"><div class="div1">
<h2><a name="expath-pkg.xsd" id="expath-pkg.xsd"></a>A Webapp schema</h2><div class="exampleInner"><pre>&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:web="http://expath.org/ns/webapp"
           targetNamespace="http://expath.org/ns/webapp"
           elementFormDefault="qualified"&gt;

   &lt;xs:element name="request"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            &lt;p&gt;The HTTP request element.&lt;/p&gt;
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      ...
   &lt;/xs:element&gt;

   &lt;xs:element name="response"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            &lt;p&gt;The HTTP response element.&lt;/p&gt;
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      ...
   &lt;/xs:element&gt;

   &lt;xs:element name="webapp"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            &lt;p&gt;The webapp descriptor.&lt;/p&gt;
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      ...
   &lt;/xs:element&gt;

&lt;/xs:schema&gt;
</pre></div></div><div class="div1">
<h2><a name="references" id="references"></a>B References</h2><dl><dt class="label"><a name="pkg" id="pkg"></a>EXPath Packaging System</dt><dd><a href="http://expath.org/spec/pkg">Packaging System</a>. Florent Georges, editor. EXPath. 9 May 2012.</dd><dt class="label"><a name="rfc3023" id="rfc3023"></a>RFC 3023</dt><dd><a href="http://www.ietf.org/rfc/rfc3023.txt">RFC
               3023: XML Media Types</a>. M. Murata, S. St. Laurent, and D. Kohn, editors.
               Internet Engineering Task Force. January, 2001.</dd></dl></div></div><script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
         </script><script type="text/javascript">
            try {
               var pageTracker = _gat._getTracker("UA-5463082-2");
               pageTracker._trackPageview();
            } catch(err) {}
         </script></body></html>